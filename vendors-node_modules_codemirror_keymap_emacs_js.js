/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunktraffic"] = self["webpackChunktraffic"] || []).push([["vendors-node_modules_codemirror_keymap_emacs_js"],{

/***/ "./node_modules/codemirror/keymap/emacs.js":
/*!*************************************************!*\
  !*** ./node_modules/codemirror/keymap/emacs.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n  else {}\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  // Internal generic kill function, used by several mapped kill \"family\" functions.\n  function _kill(cm, from, to, ring, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (ring == \"grow\" && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else if (ring !== false)\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (ring == \"grow\") lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir, ring) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      _kill(cm, cursor, findEnd(cm, cursor, by, dir), ring);\n    }\n  }\n\n  function _killRegion(cm, ring) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        _kill(cm, selection.anchor, selection.head, ring);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  cmds.setMark = function (cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function makePrompt(msg) {\n    var fragment = document.createDocumentFragment();\n    var input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"text\");\n    input.style.width = \"10em\";\n    fragment.appendChild(document.createTextNode(msg + \": \"));\n    fragment.appendChild(input);\n    return fragment;\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(makePrompt(msg), f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  // Commands. Names should match emacs function names (albeit in camelCase)\n  // except where emacs function names collide with code mirror core commands.\n\n  cmds.killRegion = function(cm) {\n    _kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"), true);\n  };\n\n  // Maps to emacs kill-line\n  cmds.killLineEmacs = repeated(function(cm) {\n    var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n    var text = cm.getRange(start, end);\n    if (!/\\S/.test(text)) {\n      text += \"\\n\";\n      end = Pos(start.line + 1, 0);\n    }\n    _kill(cm, start, end, \"grow\", text);\n  });\n\n  cmds.killRingSave = function(cm) {\n    addToRing(cm.getSelection());\n    clearMark(cm);\n  };\n\n  cmds.yank = function(cm) {\n    var start = cm.getCursor();\n    cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n    cm.setSelection(start, cm.getCursor());\n  };\n\n  cmds.yankPop = function(cm) {\n    cm.replaceSelection(popFromRing(), \"around\", \"paste\");\n  };\n\n  cmds.forwardChar = move(byChar, 1);\n\n  cmds.backwardChar = move(byChar, -1)\n\n  cmds.deleteChar = function(cm) { killTo(cm, byChar, 1, false); };\n\n  cmds.deleteForwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, 1, false);\n  };\n\n  cmds.deleteBackwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, -1, false);\n  };\n\n  cmds.forwardWord = move(byWord, 1);\n\n  cmds.backwardWord = move(byWord, -1);\n\n  cmds.killWord = function(cm) { killTo(cm, byWord, 1, \"grow\"); };\n\n  cmds.backwardKillWord = function(cm) { killTo(cm, byWord, -1, \"grow\"); };\n\n  cmds.nextLine = move(byLine, 1);\n\n  cmds.previousLine = move(byLine, -1);\n\n  cmds.scrollDownCommand = move(byPage, -1);\n\n  cmds.scrollUpCommand = move(byPage, 1);\n\n  cmds.backwardParagraph = move(byParagraph, -1);\n\n  cmds.forwardParagraph = move(byParagraph, 1);\n\n  cmds.backwardSentence = move(bySentence, -1);\n\n  cmds.forwardSentence = move(bySentence, 1);\n\n  cmds.killSentence = function(cm) { killTo(cm, bySentence, 1, \"grow\"); };\n\n  cmds.backwardKillSentence = function(cm) {\n    _kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), \"grow\");\n  };\n\n  cmds.killSexp = function(cm) { killTo(cm, byExpr, 1, \"grow\"); };\n\n  cmds.backwardKillSexp = function(cm) { killTo(cm, byExpr, -1, \"grow\"); };\n\n  cmds.forwardSexp = move(byExpr, 1);\n\n  cmds.backwardSexp = move(byExpr, -1);\n\n  cmds.markSexp = function(cm) {\n    var cursor = cm.getCursor();\n    cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n  };\n\n  cmds.transposeSexps = function(cm) {\n    var leftStart = byExpr(cm, cm.getCursor(), -1);\n    var leftEnd = byExpr(cm, leftStart, 1);\n    var rightEnd = byExpr(cm, leftEnd, 1);\n    var rightStart = byExpr(cm, rightEnd, -1);\n    cm.replaceRange(cm.getRange(rightStart, rightEnd) +\n                    cm.getRange(leftEnd, rightStart) +\n                    cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n  };\n\n  cmds.backwardUpList = repeated(toEnclosingExpr);\n\n  cmds.justOneSpace = function(cm) {\n    var pos = cm.getCursor(), from = pos.ch;\n    var to = pos.ch, text = cm.getLine(pos.line);\n    while (from && /\\s/.test(text.charAt(from - 1))) --from;\n    while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n    cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n  };\n\n  cmds.openLine = repeated(function(cm) {\n    cm.replaceSelection(\"\\n\", \"start\");\n  });\n\n  // maps to emacs 'transpose-chars'\n  cmds.transposeCharsRepeatable = repeated(function(cm) {\n    cm.execCommand(\"transposeChars\");\n  });\n\n  cmds.capitalizeWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) {\n      var letter = w.search(/\\w/);\n      if (letter == -1) return w;\n      return w.slice(0, letter) + w.charAt(letter).toUpperCase() +\n          w.slice(letter + 1).toLowerCase();\n    });\n  });\n\n  cmds.upcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toUpperCase(); });\n  });\n\n  cmds.downcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toLowerCase(); });\n  });\n\n  // maps to emacs 'undo'\n  cmds.undoRepeatable = repeated(\"undo\");\n\n  cmds.keyboardQuit = function(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  cmds.newline = repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); });\n\n  cmds.gotoLine = function(cm) {\n    var prefix = getPrefix(cm, true);\n    if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n    getInput(cm, \"Goto line\", function(str) {\n      var num;\n      if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n      cm.setCursor(num - 1);\n    });\n  };\n\n  cmds.indentRigidly = function(cm) {\n    cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n  };\n\n  cmds.exchangePointAndMark = function(cm) {\n    cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n  };\n\n  cmds.quotedInsertTab = repeated(\"insertTab\");\n\n  cmds.universalArgument = function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  };\n\n  CodeMirror.emacs = {kill: _kill, killRegion: _killRegion, repeated: repeated};\n\n  // Actual keymap\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": \"killRegion\",\n    \"Ctrl-K\": \"killLineEmacs\",\n    \"Alt-W\": \"killRingSave\",\n    \"Ctrl-Y\": \"yank\",\n    \"Alt-Y\": \"yankPop\",\n    \"Ctrl-Space\": \"setMark\",\n    \"Ctrl-Shift-2\": \"setMark\",\n    \"Ctrl-F\": \"forwardChar\",\n    \"Ctrl-B\": \"backwardChar\",\n    \"Right\": \"forwardChar\",\n    \"Left\": \"backwardChar\",\n    \"Ctrl-D\": \"deleteChar\",\n    \"Delete\": \"deleteForwardChar\",\n    \"Ctrl-H\": \"deleteBackwardChar\",\n    \"Backspace\": \"deleteBackwardChar\",\n    \"Alt-F\": \"forwardWord\",\n    \"Alt-B\": \"backwardWord\",\n    \"Alt-Right\": \"forwardWord\",\n    \"Alt-Left\": \"backwardWord\",\n    \"Alt-D\": \"killWord\",\n    \"Alt-Backspace\": \"backwardKillWord\",\n    \"Ctrl-N\": \"nextLine\",\n    \"Ctrl-P\": \"previousLine\",\n    \"Down\": \"nextLine\",\n    \"Up\": \"previousLine\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStart\",\n    \"Alt-V\": \"scrollDownCommand\",\n    \"Ctrl-V\": \"scrollUpCommand\",\n    \"PageUp\": \"scrollDownCommand\",\n    \"PageDown\": \"scrollUpCommand\",\n    \"Ctrl-Up\": \"backwardParagraph\",\n    \"Ctrl-Down\": \"forwardParagraph\",\n    \"Alt-{\": \"backwardParagraph\",\n    \"Alt-}\": \"forwardParagraph\",\n    \"Alt-A\": \"backwardSentence\",\n    \"Alt-E\": \"forwardSentence\",\n    \"Alt-K\": \"killSentence\",\n    \"Ctrl-X Delete\": \"backwardKillSentence\",\n    \"Ctrl-Alt-K\": \"killSexp\",\n    \"Ctrl-Alt-Backspace\": \"backwardKillSexp\",\n    \"Ctrl-Alt-F\": \"forwardSexp\",\n    \"Ctrl-Alt-B\": \"backwardSexp\",\n    \"Shift-Ctrl-Alt-2\": \"markSexp\",\n    \"Ctrl-Alt-T\": \"transposeSexps\",\n    \"Ctrl-Alt-U\": \"backwardUpList\",\n    \"Alt-Space\": \"justOneSpace\",\n    \"Ctrl-O\": \"openLine\",\n    \"Ctrl-T\": \"transposeCharsRepeatable\",\n    \"Alt-C\": \"capitalizeWord\",\n    \"Alt-U\": \"upcaseWord\",\n    \"Alt-L\": \"downcaseWord\",\n    \"Alt-;\": \"toggleComment\",\n    \"Ctrl-/\": \"undoRepeatable\",\n    \"Shift-Ctrl--\": \"undoRepeatable\",\n    \"Ctrl-Z\": \"undoRepeatable\",\n    \"Cmd-Z\": \"undoRepeatable\",\n    \"Ctrl-X U\": \"undoRepeatable\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Shift-Alt-,\": \"goDocStart\",\n    \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\",\n    \"Ctrl-R\": \"findPersistentPrev\",\n    \"Ctrl-G\": \"keyboardQuit\",\n    \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": \"newline\",\n    \"Tab\": \"indentAuto\",\n    \"Alt-G G\": \"gotoLine\",\n    \"Ctrl-X Tab\": \"indentRigidly\",\n    \"Ctrl-X Ctrl-X\": \"exchangePointAndMark\",\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X H\": \"selectAll\",\n    \"Ctrl-Q Tab\": \"quotedInsertTab\",\n    \"Ctrl-U\": \"universalArgument\",\n    \"fallthrough\": \"default\"\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n\n\n//# sourceURL=webpack://traffic/./node_modules/codemirror/keymap/emacs.js?");

/***/ })

}]);